# Copilot instructions for InstaTrack

- **What this app does**: Python tool that collects Instagram followers/following via `instagrapi`, stores snapshots/changes in MongoDB (with automatic `mongomock` fallback), and serves a Flask dashboard + settings page + CLI.
- **Top entrypoints**: `main.py` with subcommands `run` (collect once), `report` (print/report, optional `--csv`), `web` (Flask UI), `schedule` (APScheduler loop). Web app factory is `web/app.py:create_app`.
- **Config loading/writing**:
  - `config/settings.py` loads the first `.env` it finds (repo root > config/.env > cwd) and exposes a global `settings`. It also ensures `data/cache` and `data/logs` exist.
  - `config/env_store.py` is the only writer to `.env`; `SettingsService` uses it to persist `TARGET_ACCOUNTS`, `INSTAGRAM_SESSIONID`, and `AUTO_REFRESH_INTERVAL_SECONDS`. Prefer calling service methods, not hand-editing env files from code.
- **Services & boundaries**:
  - `TrackerService` (services/tracker_service.py) orchestrates fetch → diff → store. Uses `utils.insta_client.InstaClient` (instagrapi wrapper) and `utils.comparer` to build change events.
  - `ReportService` (services/report_service.py) is read-only: stats, history, comparisons, CSV export. Used by both CLI and web.
  - `SettingsService` owns mutations to config/env + Insta account checks/follow requests; surfaced via `/api/settings/*` in `web/app.py` and `web/static/js/settings.js`.
  - `AIChatService` wires Gemini (`GEMINI_API_KEY`) to answer questions on stored lists (see `services/ai_service.py`).
- **Persistence**: `utils/storage.py` wraps MongoDB; falls back to `mongomock` when `USE_MOCK_DB=1` or connection fails. Collections default to `snapshots` and `changes`; indexes are created automatically.
- **Scheduling**: `utils/scheduler.py` uses APScheduler; `TrackerScheduler.start()` is triggered by `/api/schedule` and the `schedule` CLI command. Uses `settings.scrape_time` (UTC hour/minute).
- **Web UI**:
  - Flask routes in `web/app.py`; templates in `web/templates`; static assets in `web/static` (Chart.js for graphs, `settings.js` for settings UX).
  - Settings page posts to `/api/settings` endpoints; `settings.js` expects `data-settings` JSON from the template. Keep JS side-effects minimal—duplicated function names break the page.
- **Tests**: run `pytest` (root). Set `USE_MOCK_DB=1` to avoid real Mongo. Tests cover comparer logic, storage (with mongomock), services, and instagrapi client stubs.
- **Logging**: `utils/logger.py` configures app-level logger writing to `data/logs/instatrack.log`; honors `LOG_LEVEL`.
- **Common tweaks**:
  - To change target accounts, session, or auto-refresh, go through `SettingsService` methods so `.env` stays in sync.
  - When adding endpoints, reuse `report_service`/`tracker_service` singletons in `web/app.py` to keep state consistent and share scheduler.
- **Local workflows**:
  - Web dev: `python main.py web --debug` (hot reload) and hit `http://127.0.0.1:5000`.
  - One-off capture: `python main.py run` (requires `TARGET_ACCOUNTS` and Instagram auth set).
  - Daily run: `python main.py schedule` (respects `SCRAPE_HOUR_UTC`/`SCRAPE_MINUTE_UTC`).
- **External deps**: `instagrapi`, `pymongo`/`mongomock`, `flask`, `apscheduler`, `google-generativeai` (for Gemini). Make sure `requirements.txt` stays the source of truth.
- **Style expectations**:
  - Keep business logic in services, not in Flask routes/JS.
  - Preserve French UX copy in templates/JS.
  - Favor pure functions in `utils` and reuse existing helpers (`_resolve_range`, `_serialize_change`, etc.) in `ReportService` instead of reimplementing.
